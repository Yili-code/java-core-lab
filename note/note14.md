# 多型（Polymorphism）

**多型**是指**同一種操作**（例如方法呼叫）能根據物件的**實際型別**表現出**不同行為**。在 Java 中，常透過**父類別型別的引用**指向**子類別型別的物件**來達成。

---

## 目錄

1. [核心語法](#核心語法)

2. [靜態多型 vs 動態多型](#靜態多型-vs-動態多型)

3. [為什麼重要](#為什麼重要)

4. [在後端開發中的應用](#在後端開發中的應用)

---

## 核心語法

```java
Parent obj = new Child();
```

- `obj` 的**編譯期型別**是 `Parent`（編譯器據此決定你可呼叫哪些成員）。

- **執行期型別**是 `Child`；被覆寫的方法會依**實際物件型別**來呼叫（動態派送）。

---

## Polymorphism 好處

1. Method 使用 superclass 作為參數，可以接收所有 subclass 的對象

2. 根據傳遞不同對象，調用 subclass 不同 method

---

## 類型轉換

分成**自動類型轉換**以及**強制類型轉換**。強制類型轉換可以轉換成真正的子類類型，從而調用子類獨有的功能

```java
Person p = new Student();
Student s = (Student)p;
---

## 靜態多型 vs 動態多型

| 類型 | 機制 | 解析時機 | 範例 |
|------|------|----------|------|
| **靜態多型** | **方法多載（Overloading）** — 相同方法名、不同參數列表。 | **編譯期** | `println(String)` 與 `println(int)` |
| **動態多型** | **方法覆寫（Overriding）** — 子類別提供父類別方法自己的實作。 | **執行期** | `Parent p = new Child(); p.doWork();` 會執行 `Child` 的 `doWork()` |

動態多型是**擴展性**的關鍵：可在不修改依賴父類別型別的程式碼的前提下，新增子類型。

---

## 為什麼重要

- **擴展性** — 透過新增子類別加入新行為，使用父類別型別的既有程式碼無需改動即可受益。

- **抽象** — 呼叫端依賴抽象型別（介面或父類別），而非具體實作。

- **可測試性** — 依賴可替換為實作同一型別的 mock 或 stub。

---

## 在後端開發中的應用

- **依賴注入（Dependency Injection, DI）** — 框架（如 Spring）依介面或抽象型別注入實作；多型讓你在不改呼叫端的情況下替換實作。

- **API 與外掛** — 定義介面或基底類別；由第三方或內部程式提供具體實作，並以多型方式使用。
